From 54e1e55812447c6e6303d59519972c2dc63ee94e Mon Sep 17 00:00:00 2001
From: goldenleaves <houbai.zzc@alibaba-inc.com>
Date: Mon, 20 Jun 2022 09:07:20 +0000
Subject: [PATCH] hiactor hackings

---
 include/seastar/core/task.hh       | 27 ++++++++++++++++++++++++++-
 include/seastar/net/api.hh         | 22 ++++++++++++++++++++++
 include/seastar/net/posix-stack.hh | 12 ++++++++++++
 src/core/reactor.cc                | 18 +++++++++++++++---
 src/net/posix-stack.cc             |  6 ++++++
 5 files changed, 81 insertions(+), 4 deletions(-)

diff --git a/include/seastar/core/task.hh b/include/seastar/core/task.hh
index 13b315f3..be3969e4 100644
--- a/include/seastar/core/task.hh
+++ b/include/seastar/core/task.hh
@@ -27,6 +27,26 @@
 
 namespace seastar {
 
+/// hiactor hacking
+
+class task;
+
+class execution_context {
+public:
+    virtual void add_task(task* t) = 0;
+    virtual void add_urgent_task(task* t) = 0;
+};
+
+extern __thread execution_context* local_ec;
+
+inline void set_local_ec(execution_context* ec) {
+    local_ec = ec;
+}
+
+inline execution_context* get_local_ec() {
+    return local_ec;
+}
+
 class task {
     scheduling_group _sg;
 #ifdef SEASTAR_TASK_BACKTRACE
@@ -42,12 +62,17 @@ class task {
     scheduling_group set_scheduling_group(scheduling_group new_sg) noexcept{
         return std::exchange(_sg, new_sg);
     }
+
+    execution_context* _ec;
 public:
-    explicit task(scheduling_group sg = current_scheduling_group()) noexcept : _sg(sg) {}
+    explicit task(scheduling_group sg = current_scheduling_group()) noexcept : _sg(sg), _ec(get_local_ec()) {}
+    explicit task(execution_context* ec, scheduling_group sg = current_scheduling_group()) noexcept : _sg(sg), _ec(ec) {}
     virtual void run_and_dispose() noexcept = 0;
+    virtual void cancel() {}
     /// Returns the next task which is waiting for this task to complete execution, or nullptr.
     virtual task* waiting_task() noexcept = 0;
     scheduling_group group() const { return _sg; }
+    execution_context* ec() const { return _ec; }
     shared_backtrace get_backtrace() const;
 #ifdef SEASTAR_TASK_BACKTRACE
     void make_backtrace() noexcept;
diff --git a/include/seastar/net/api.hh b/include/seastar/net/api.hh
index 666b58fc..1fd1e532 100644
--- a/include/seastar/net/api.hh
+++ b/include/seastar/net/api.hh
@@ -134,6 +134,26 @@ class udp_channel {
 
 class network_interface_impl;
 
+/// hiactor hacking
+/// customized load balancing policy
+struct lba_policy {
+    lba_policy() = default;
+    virtual ~lba_policy() = default;
+    virtual unsigned get_cpu(uint32_t addr, uint16_t port) = 0;
+};
+
+class customized_lba {
+    static std::unique_ptr<lba_policy> impl_;
+public:
+    static inline unsigned get_cpu(uint32_t addr, uint16_t port) {
+        return impl_->get_cpu(addr, port);
+    }
+    static inline void set_policy(std::unique_ptr<lba_policy>&& policy) {
+        assert(!impl_ && "Error: policy is already setted.");
+        impl_ = std::move(policy);
+    }
+};
+
 } /* namespace net */
 
 /// \addtogroup networking-module
@@ -311,6 +331,8 @@ class server_socket {
         port,
         // This algorithm distributes all new connections to listen_options::fixed_cpu shard only.
         fixed,
+        // hiactor hacking
+        customized,
         default_ = connection_distribution
     };
     /// Constructs a \c server_socket without being bound to any address
diff --git a/include/seastar/net/posix-stack.hh b/include/seastar/net/posix-stack.hh
index e76d7aff..30a7e107 100644
--- a/include/seastar/net/posix-stack.hh
+++ b/include/seastar/net/posix-stack.hh
@@ -60,6 +60,14 @@ class conntrack {
             _cpu_load[cpu]++;
             return cpu;
         }
+        /// hiactor hacking
+        shard_id customized_cpu(socket_address &sa) {
+            auto cpu = customized_lba::get_cpu(
+                ntoh(sa.as_posix_sockaddr_in().sin_addr.s_addr),
+                ntoh(sa.as_posix_sockaddr_in().sin_port));
+            _cpu_load[cpu]++;
+            return cpu;
+        }
     };
 
     lw_shared_ptr<load_balancer> _lb;
@@ -102,6 +110,10 @@ class conntrack {
     handle get_handle(shard_id cpu) {
         return handle(_lb->force_cpu(cpu), _lb);
     }
+    /// hiactor hacking
+    handle get_handle(socket_address &sa) {
+        return handle{_lb->customized_cpu(sa), _lb};
+    }
 };
 
 class posix_data_source_impl final : public data_source_impl, private internal::buffer_allocator {
diff --git a/src/core/reactor.cc b/src/core/reactor.cc
index 6f5683d7..e001f82f 100644
--- a/src/core/reactor.cc
+++ b/src/core/reactor.cc
@@ -1105,7 +1105,10 @@ void cpu_stall_detector::update_config(cpu_stall_detector_config cfg) {
 
 void cpu_stall_detector::maybe_report() {
     if (_reported++ < _max_reports_per_minute) {
+        /// hiactor hacking
+        #ifdef HIACTOR_CPU_STALL_REPORT
         generate_trace();
+        #endif
     }
 }
 // We use a tick at every timer firing so we can report suppressed backtraces.
@@ -1156,7 +1159,10 @@ void cpu_stall_detector_posix_timer::arm_timer() {
 
 void cpu_stall_detector::start_task_run(sched_clock::time_point now) {
     if (now > _rearm_timer_at) {
+        /// hiactor hacking
+        #ifdef HIACTOR_CPU_STALL_REPORT
         report_suppressions(now);
+        #endif
         _report_at = 1;
         _run_started_at = now;
         _rearm_timer_at = now + _threshold * _report_at;
@@ -3063,7 +3069,7 @@ class poller::registration_task final : public task {
         delete this;
     }
     task* waiting_task() noexcept override { return nullptr; }
-    void cancel() {
+    void cancel() override /* hiactor hacking */ {
         _p = nullptr;
     }
     void moved(poller* p) {
@@ -3409,12 +3415,16 @@ future<size_t> readable_eventfd::wait() {
     });
 }
 
+/// hiactor hacking
 void schedule(task* t) noexcept {
-    engine().add_task(t);
+    auto* ec = t->ec();
+    (ec == nullptr) ? engine().add_task(t) : ec->add_task(t);
 }
 
+/// hiactor hacking
 void schedule_urgent(task* t) noexcept {
-    engine().add_urgent_task(t);
+    auto* ec = t->ec();
+    (ec == nullptr) ? engine().add_urgent_task(t) : ec->add_urgent_task(t);
 }
 
 }
@@ -4240,6 +4250,8 @@ bool smp::pure_poll_queues() {
 }
 
 __thread reactor* local_engine;
+/// hiactor hacking
+__thread execution_context* local_ec{nullptr};
 
 void report_exception(std::string_view message, std::exception_ptr eptr) noexcept {
     seastar_logger.error("{}: {}", message, eptr);
diff --git a/src/net/posix-stack.cc b/src/net/posix-stack.cc
index 3080c653..50f9590f 100644
--- a/src/net/posix-stack.cc
+++ b/src/net/posix-stack.cc
@@ -74,6 +74,9 @@ namespace net {
 
 using namespace seastar;
 
+/// hiactor hacking
+std::unique_ptr<lba_policy> customized_lba::impl_{nullptr};
+
 class posix_connected_socket_operations {
 public:
     virtual ~posix_connected_socket_operations() = default;
@@ -476,6 +479,9 @@ posix_server_socket_impl::accept() {
                 return _conntrack.get_handle(ntoh(sa.as_posix_sockaddr_in().sin_port) % smp::count);
             case server_socket::load_balancing_algorithm::fixed:
                 return _conntrack.get_handle(_fixed_cpu);
+            /// hiactor hacking
+            case server_socket::load_balancing_algorithm::customized:
+                return _conntrack.get_handle(sa);
             default: abort();
             }
         } ();
-- 
2.25.1

